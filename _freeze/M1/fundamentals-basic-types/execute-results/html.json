{
  "hash": "7f5991b02e879b5e5c679b2dfd4e68f5",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Basic Types and Data Structures in Julia\"\npage-layout: article\njupyter: julia-1.11\n---\n\n\n\nIn Julia, understanding the fundamental types and data structures is essential for efficient coding and problem-solving. This page provides an introduction to some of the basic types in Julia, including integers, floating-point numbers, strings, and composite types like arrays and tuples. We’ll also explore more advanced data structures and their practical uses.\n\nYou'll learn about:\n\n- **Basic Types** such as integers, floating-point numbers, and strings.\n- **Data Structures** like arrays, vectors, matrices, tuples, and `NamedTuple`.\n- The importance of **Type Declarations** and how to use them effectively.\n- How to work with **Collections** and **Composite Types** to model more complex data.\n\nWhether you're a beginner or looking to deepen your understanding of Julia's type system, this page will help you get familiar with the core building blocks for handling data efficiently in Julia.\n\n## Introduction to Types in Julia\n\nJulia is a dynamically typed language, meaning that variable types are determined at runtime. However, Julia also supports strong typing, which means that types are important and can be explicitly specified when needed. Understanding types in Julia is essential for writing efficient code, as the language uses Just-In-Time (JIT) compilation to optimize based on variable types.\n\n### Dynamic Typing\nIn Julia, variables do not require explicit type declarations. The type of a variable is inferred based on the value assigned to it.\n\n::: {#167ede22 .cell execution_count=2}\n``` {.julia .cell-code}\nx = 10          # x is inferred to be of type Int64\ny = 3.14        # y is inferred to be of type Float64\nz = \"Hello\"     # z is inferred to be of type String\nnothing #| hide_line\n```\n:::\n\n\nEven though Julia automatically infers types, you can still explicitly specify them when necessary, particularly for performance optimization or for ensuring that a variable matches a particular type.\n\n### Strong Typing\nWhile Julia uses dynamic typing, it is strongly typed. This means that Julia will enforce type constraints on operations, and will raise errors when an operation is attempted with incompatible types.\n\n::: {#0d6b8851 .cell execution_count=3}\n``` {.julia .cell-code}\na = 5           # Integer\nb = 2.0         # Float\n\n# This will raise an error because you can't add an integer and a string\nc = a + \"hello\"  # Error: cannot convert string to Int\n```\n\n::: {.cell-output .cell-output-error}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre>MethodError: no method matching +(::Int64, ::String)\nThe function `+` exists, but no method is defined for this combination of argument types.\n\nClosest candidates are:\n  +(::Any, ::Any, <span class=\"ansi-bright-red-fg\">::Any</span>, <span class=\"ansi-bright-red-fg\">::Any...</span>)\n<span class=\"ansi-bright-black-fg\">   @</span> <span class=\"ansi-bright-black-fg\">Base</span> <span style=\"text-decoration:underline\" class=\"ansi-bright-black-fg\">operators.jl:596</span>\n  +(::Real, <span class=\"ansi-bright-red-fg\">::Complex{Bool}</span>)\n<span class=\"ansi-bright-black-fg\">   @</span> <span class=\"ansi-bright-black-fg\">Base</span> <span style=\"text-decoration:underline\" class=\"ansi-bright-black-fg\">complex.jl:322</span>\n  +(::Integer, <span class=\"ansi-bright-red-fg\">::AbstractChar</span>)\n<span class=\"ansi-bright-black-fg\">   @</span> <span class=\"ansi-bright-black-fg\">Base</span> <span style=\"text-decoration:underline\" class=\"ansi-bright-black-fg\">char.jl:247</span>\n  ...\n\n\nStacktrace:\n [1] top-level scope\n   @ In[141]:5</pre>\n```\n:::\n\n:::\n:::\n\n\nJulia allows flexibility compared to statically typed languages like C or Java, but still ensures that operations make sense for the types involved.\n\n### Type System and Performance\nThe type system in Julia plays a key role in performance. By inferring or specifying types, Julia's JIT compiler can optimize code for specific data types, leading to faster execution. For example, when types are known at compile time, Julia can generate machine code tailored for the specific types involved.\n\nJulia’s type system also supports abstract types, allowing for more flexible and generic code, as well as parametric types that let you define functions or types that work with any data type.\n\n### Summary\n- Julia is dynamically typed but enforces strong typing.\n- Types are inferred from the values assigned to variables.\n- Julia optimizes performance based on types, making type information crucial.\n\n## Basic Types\n\nJulia has several basic (or primitive) types that are fundamental to working with the language. These include numerical types, characters, and strings. Understanding these types is crucial as they form the building blocks for more complex data structures.\n\n### Common Basic Types\n\n- **`Int`**: Represents integer values. Julia has multiple types of integers, such as `Int8`, `Int16`, `Int32`, and `Int64` depending on the desired size. By default, `Int` refers to the most appropriate integer type for the system (usually `Int64` on modern systems).\n  \n- **`Float64`**: Represents floating-point numbers with double precision.\n  \n- **`String`**: Represents sequences of characters.\n\n- **`Bool`**: Represents Boolean values, i.e., `true` or `false`.\n\n- **`Char`**: Represents individual Unicode characters.\n\n### Example Usage of Basic Types\n\n::: {#41d0628c .cell execution_count=4}\n``` {.julia .cell-code}\n# Integer type (default is Int64)\na = 42         # a is of type Int64\n\n# Float type (default is Float64)\nb = 3.14       # b is of type Float64\n\n# String type\nc = \"Hello\"    # c is of type String\n\n# Boolean type\nd = true       # d is of type Bool\n\n# Char type\ne = 'α'        # e is of type Char\nnothing #| hide_line\n```\n:::\n\n\nThese basic types are often used for simple calculations and conditionals. Julia allows operations between different types, but it will raise an error if the types are incompatible.\n\n## Collections and Data Structures\n\n### Arrays, Vectors, and Matrices\n\nIn Julia, arrays are fundamental data structures that can hold elements of any type. Arrays can be one-dimensional (vectors) or two-dimensional (matrices), and they can hold data of various types.\n\n- **Creating an Array**:\n\n::: {#b35089a3 .cell execution_count=5}\n``` {.julia .cell-code}\narr = [1, 2, 3, 4]  # A simple 1D array (vector)\n```\n\n::: {.cell-output .cell-output-display execution_count=143}\n```\n4-element Vector{Int64}:\n 1\n 2\n 3\n 4\n```\n:::\n:::\n\n\n::: {#55f63961 .cell execution_count=6}\n``` {.julia .cell-code}\nmatrix = [1 2 3; 4 5 6]  # A 2D array (matrix)\n```\n\n::: {.cell-output .cell-output-display execution_count=144}\n```\n2×3 Matrix{Int64}:\n 1  2  3\n 4  5  6\n```\n:::\n:::\n\n\n- **Accessing Array Elements**:\n\n::: {#4cea09f7 .cell execution_count=7}\n``` {.julia .cell-code}\narr[1]   # Access the first element of the array\n```\n\n::: {.cell-output .cell-output-display execution_count=145}\n```\n1\n```\n:::\n:::\n\n\n::: {#37fc8acf .cell execution_count=8}\n``` {.julia .cell-code}\nmatrix[2, 3]  # Access the element in the second row, third column\n```\n\n::: {.cell-output .cell-output-display execution_count=146}\n```\n6\n```\n:::\n:::\n\n\n### Slicing of Vectors and Matrices\n\nYou can extract slices (sub-arrays) of vectors and matrices in Julia. The slicing syntax allows you to access specific portions of an array.\n\n- **Slicing a vector**:\n\n::: {#d0b7883c .cell execution_count=9}\n``` {.julia .cell-code}\narr[2:4]  # Extracts elements from index 2 to 4: [2, 3, 4]\n```\n\n::: {.cell-output .cell-output-display execution_count=147}\n```\n3-element Vector{Int64}:\n 2\n 3\n 4\n```\n:::\n:::\n\n\n- **Slicing a matrix**:\n\n::: {#d02e2a47 .cell execution_count=10}\n``` {.julia .cell-code}\nmatrix[1, :]   # Extracts the first row: [1, 2, 3]\n```\n\n::: {.cell-output .cell-output-display execution_count=148}\n```\n3-element Vector{Int64}:\n 1\n 2\n 3\n```\n:::\n:::\n\n\n::: {#1e5a3415 .cell execution_count=11}\n``` {.julia .cell-code}\nmatrix[:, 2]   # Extracts the second column: [2, 5]\n```\n\n::: {.cell-output .cell-output-display execution_count=149}\n```\n2-element Vector{Int64}:\n 2\n 5\n```\n:::\n:::\n\n\n### Mutation of Arrays\n\nArrays in Julia are mutable, meaning their elements can be changed after creation. The `.=` operator is commonly used to apply element-wise operations.\n\n- **Modify an individual element**:\n\n::: {#4bc32518 .cell execution_count=12}\n``` {.julia .cell-code}\narr[2] = 99  # Change the second element to 99\n```\n\n::: {.cell-output .cell-output-display execution_count=150}\n```\n99\n```\n:::\n:::\n\n\n- **Element-wise operation with `.=`**:\n\n::: {#324612a7 .cell execution_count=13}\n``` {.julia .cell-code}\narr .+= 10  # Adds 10 to each element of the array, resulting in [11, 12, 13, 14]\n```\n\n::: {.cell-output .cell-output-display execution_count=151}\n```\n4-element Vector{Int64}:\n  11\n 109\n  13\n  14\n```\n:::\n:::\n\n\n::: {#a453e2fe .cell execution_count=14}\n``` {.julia .cell-code}\nmatrix .*= 2  # Multiplies each element of the matrix by 2, resulting in [2 4 6; 8 10 12]\n```\n\n::: {.cell-output .cell-output-display execution_count=152}\n```\n2×3 Matrix{Int64}:\n 2   4   6\n 8  10  12\n```\n:::\n:::\n\n\n- **Push an element into an array** (mutates the array by adding a new element):\n\n::: {#54f4fdfe .cell execution_count=15}\n``` {.julia .cell-code}\npush!(arr, 40)  # Adds 40 to the end of the array\n```\n\n::: {.cell-output .cell-output-display execution_count=153}\n```\n5-element Vector{Int64}:\n  11\n 109\n  13\n  14\n  40\n```\n:::\n:::\n\n\n- **Pop an element from an array** (removes the last element):\n\n::: {#c5231929 .cell execution_count=16}\n``` {.julia .cell-code}\npop!(arr)  # Removes the last element, which is 40 in this case\n```\n\n::: {.cell-output .cell-output-display execution_count=154}\n```\n40\n```\n:::\n:::\n\n\n### Special Arrays\n\nJulia has built-in functions to create arrays with predefined values:\n\n- **Create an array of zeros**:\n\n::: {#c69e3021 .cell execution_count=17}\n``` {.julia .cell-code}\nzeros(3)  # Creates an array of zeros with 3 elements: [0.0, 0.0, 0.0]\n```\n\n::: {.cell-output .cell-output-display execution_count=155}\n```\n3-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n```\n:::\n:::\n\n\n- **Create an array of ones**:\n\n::: {#dc1155a8 .cell execution_count=18}\n``` {.julia .cell-code}\nones(2, 3)  # Creates a 2x3 matrix filled with ones: [1.0 1.0 1.0; 1.0 1.0 1.0]\n```\n\n::: {.cell-output .cell-output-display execution_count=156}\n```\n2×3 Matrix{Float64}:\n 1.0  1.0  1.0\n 1.0  1.0  1.0\n```\n:::\n:::\n\n\n### Tuples and Named Tuples\n\n- **Tuple** is an ordered collection of elements, which can hold elements of different types.\n\n::: {#af34214d .cell execution_count=19}\n``` {.julia .cell-code}\nt = (1, \"Julia\", true)  # A tuple with three elements\n```\n\n::: {.cell-output .cell-output-display execution_count=157}\n```\n(1, \"Julia\", true)\n```\n:::\n:::\n\n\n- **NamedTuple** is a special kind of tuple where elements are associated with names (keys).\n\n::: {#39dedfc7 .cell execution_count=20}\n``` {.julia .cell-code}\nnt = (name = \"Alice\", age = 25)  # A NamedTuple with named fields\n```\n\n::: {.cell-output .cell-output-display execution_count=158}\n```\n(name = \"Alice\", age = 25)\n```\n:::\n:::\n\n\nYou can access the elements by their name:\n\n::: {#c6e2792e .cell execution_count=21}\n``` {.julia .cell-code}\nnt.name  # Access the field 'name' of the NamedTuple, returns \"Alice\"\n```\n\n::: {.cell-output .cell-output-display execution_count=159}\n```\n\"Alice\"\n```\n:::\n:::\n\n\n- **Mutation of a Tuple**:  \nTuples are immutable, so attempting to change their elements will result in an error.\n\n::: {#c5e237e9 .cell execution_count=22}\n``` {.julia .cell-code}\nt[1] = 99  # Trying to modify a tuple element will result in an error\n```\n\n::: {.cell-output .cell-output-error}\n```\nLoadError: MethodError: no method matching setindex!(::Tuple{Int64, String, Bool}, ::Int64, ::Int64)\nThe function `setindex!` exists, but no method is defined for this combination of argument types.\nMethodError: no method matching setindex!(::Tuple{Int64, String, Bool}, ::Int64, ::Int64)\nThe function `setindex!` exists, but no method is defined for this combination of argument types.\n\nStacktrace:\n [1] top-level scope\n   @ In[160]:1\n```\n:::\n:::\n\n\nThe above line will raise an error because tuples are immutable in Julia, and their elements cannot be modified after creation.\n\n## Composite Types\n\n### Introduction to `struct`\n\nIn Julia, you can define your own custom data types using the `struct` keyword. Composite types are user-defined types that group together different pieces of data into one object. A `struct` is a great way to create a type that can represent a complex entity with multiple fields.\n\n- **Creating a custom `struct`**:\n\n::: {#8fce0f55 .cell execution_count=23}\n``` {.julia .cell-code}\n# Define a simple struct for a point in 2D space\nstruct Point\n    x::Float64\n    y::Float64\nend\n```\n:::\n\n\nHere, we created a `Point` struct with two fields: `x` and `y`, both of which are of type `Float64`.\n\n- **Creating an instance of a struct**:\n\n::: {#e3da89ed .cell execution_count=24}\n``` {.julia .cell-code}\np = Point(3.0, 4.0)  # Creates a Point with x = 3.0 and y = 4.0\n```\n\n::: {.cell-output .cell-output-display execution_count=162}\n```\nPoint(3.0, 4.0)\n```\n:::\n:::\n\n\n- **Accessing fields of a struct**:\n\n::: {#50544fa4 .cell execution_count=25}\n``` {.julia .cell-code}\np.x  # Access the 'x' field of the Point instance\np.y  # Access the 'y' field of the Point instance\n```\n\n::: {.cell-output .cell-output-display execution_count=163}\n```\n4.0\n```\n:::\n:::\n\n\nYou can access the fields of a struct directly using dot notation, as shown above.\n\n### Mutability of `struct`\n\nIn Julia, structs are **immutable** by default, meaning once you create an instance of a struct, its fields cannot be changed. However, you can create **mutable structs** by using the `mutable struct` keyword, which allows modification of field values after creation.\n\n- **Creating a mutable struct**:\n\n::: {#22d06b50 .cell execution_count=26}\n``` {.julia .cell-code}\nmutable struct MutablePoint\n    x::Float64\n    y::Float64\nend\n```\n:::\n\n\nNow you can modify the fields of `MutablePoint` instances after they are created.\n\n::: {#82b1f961 .cell execution_count=27}\n``` {.julia .cell-code}\nmp = MutablePoint(1.0, 2.0)\nmp.x = 3.0  # Modify the 'x' field\nnothing #| hide_line\n```\n:::\n\n\n### Example: `struct` for a Circle\n\nWe can create a more complex type, such as a `Circle`, which has a center represented by a `Point` and a radius:\n\n::: {#dd7a8ff2 .cell execution_count=28}\n``` {.julia .cell-code}\nstruct Circle\n    center::Point\n    radius::Float64\nend\n```\n:::\n\n\n- **Creating an instance of `Circle`**:\n\n::: {#360e0d90 .cell execution_count=29}\n``` {.julia .cell-code}\nc = Circle(Point(0.0, 0.0), 5.0)  # Create a circle with center (0, 0) and radius 5\n```\n\n::: {.cell-output .cell-output-display execution_count=167}\n```\nCircle(Point(0.0, 0.0), 5.0)\n```\n:::\n:::\n\n\n- **Accessing fields of a nested struct**:\n\n::: {#c75aedbf .cell execution_count=30}\n``` {.julia .cell-code}\nc.center.x  # Access the x field of the center of the circle\nc.center.y  # Access the y field of the center of the circle\nc.radius    # Access the radius of the circle\nnothing #| hide_line\n```\n:::\n\n\n### Conclusion\n\nIn Julia, `struct` allows you to create complex custom types that can hold different types of data. By default, structs are immutable, but you can use `mutable struct` if you need to change the data after creation. This is useful for organizing and managing related data in your programs.\n\n## Exercices\n\n### Exercise 1: Creating a Shape System\n\nCreate a system to represent different geometric shapes (like a **Rectangle**, **Circle**, and **Point**) using the following requirements:\n\n1. **Define a `Point` struct** with `x` and `y` coordinates of type `Float64`.\n2. **Define a `Rectangle` struct** with fields `length` and `width` of type `Float64`. Use the `Point` struct to represent the bottom-left corner of the rectangle.\n3. **Define a `Circle` struct** with a `Point` for the center and a `radius` of type `Float64`.\n4. Write a **function `area(shape)`** that computes the area of the given shape:\n   - The area of a rectangle is `length * width`.\n   - The area of a circle is `π * radius^2`.\n\n::: {.callout-tip collapse=\"true\" icon=false}\n## Hint for Exercise 1:\n- Use **struct** to define `Point`, `Rectangle`, and `Circle`.\n- Use **dot notation** to access the fields of the structs.\n- Use **conditional logic** (e.g., `typeof()`) to handle different shapes in the `area` function.\n- For the circle, use `π = 3.141592653589793`.\n:::\n\n::: {.callout-caution collapse=\"true\" icon=false}\n## Correction of Exercise 1:\n\n::: {#de68577c .cell execution_count=31}\n``` {.julia .cell-code}\n# Define the Point struct\nstruct Point\n    x::Float64\n    y::Float64\nend\n\n# Define the Rectangle struct\nstruct Rectangle\n    bottom_left::Point\n    length::Float64\n    width::Float64\nend\n\n# Define the Circle struct\nstruct Circle\n    center::Point\n    radius::Float64\nend\n\n# Function to calculate the area\nfunction area(shape)\n    if typeof(shape) == Rectangle\n        return shape.length * shape.width\n    elseif typeof(shape) == Circle\n        return π * shape.radius^2\n    else\n        throw(ArgumentError(\"Unsupported shape\"))\n    end\nend\n\n# Example usage\np1 = Point(0.0, 0.0)\nr1 = Rectangle(p1, 3.0, 4.0)\nc1 = Circle(p1, 5.0)\n\nprintln(\"Area of rectangle: \", area(r1))  # Should print 12.0\nprintln(\"Area of circle: \", area(c1))     # Should print 78.53981633974483\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nArea of rectangle: 12.0\nArea of circle: 78.53981633974483\n```\n:::\n:::\n\n\n:::\n\n### Exercise 2: Working with Complex Numbers and Arrays\n\n1. Create two **complex numbers** `z1` and `z2` of type `Complex{Float64}`.\n2. Write a function `add_complex(z1, z2)` that adds two complex numbers and returns the result.\n3. Create an **array** of complex numbers and use the `map` function to add 2.0 to the real part of each complex number.\n4. Create a function `max_real_part` that returns the complex number with the largest real part from an array of complex numbers.\n\n::: {.callout-tip collapse=\"true\" icon=false}\n## Hint for Exercise 2:\n- Use the `Complex{T}` type to create complex numbers. \n- You can access the real and imaginary parts of a complex number with `real(z)` and `imag(z)`.\n- Use the `map` function to apply a transformation to each element of an array.\n- Compare the real parts of the complex numbers using `real(z)` to find the maximum.\n:::\n\n::: {.callout-caution collapse=\"true\" icon=false}\n## Correction of Exercise 2:\n\n::: {#7c64317a .cell execution_count=32}\n``` {.julia .cell-code}\n# Create two complex numbers\nz1 = Complex{Float64}(3.0, 4.0)  # z1 = 3.0 + 4.0im\nz2 = Complex{Float64}(1.0, 2.0)  # z2 = 1.0 + 2.0im\n\n# Function to add two complex numbers\nfunction add_complex(z1, z2)\n    return z1 + z2\nend\n\n# Add 2.0 to the real part of each complex number in an array\narr = [Complex{Float64}(3.0, 4.0), Complex{Float64}(1.0, 2.0), Complex{Float64}(5.0, 6.0)]\nnew_arr = map(z -> Complex(real(z) + 2.0, imag(z)), arr)\n\nprintln(\"New array with modified real parts: \", new_arr)\n\n# Function to find the complex number with the largest real part\nfunction max_real_part(arr)\n    max_z = arr[1]\n    for z in arr\n        if real(z) > real(max_z)\n            max_z = z\n        end\n    end\n    return max_z\nend\n\n# Find the complex number with the largest real part\nmax_z = max_real_part(arr)\nprintln(\"Complex number with the largest real part: \", max_z)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNew array with modified real parts: ComplexF64[5.0 + 4.0im, 3.0 + 2.0im, 7.0 + 6.0im]\nComplex number with the largest real part: 5.0 + 6.0im\n```\n:::\n:::\n\n\n:::\n\n### Exercise 3: Manipulating Arrays and Tuples\n\n1. Create an **array** `arr` of integers from 1 to 10. \n2. Use broadcasting (`.=`) to multiply all elements of the array by 2.\n3. Create a **tuple** `t` with three elements: a string, an integer, and a float.\n4. Try to mutate the first element of the tuple and handle any errors using a `try-catch` block.\n5. Create a **NamedTuple** `nt` with fields `name`, `age`, and `height`, and initialize it with your details.\n\n::: {.callout-tip collapse=\"true\" icon=false}\n## Hint for Exercise 3:\n- Use the `.` operator for broadcasting and mutation of arrays.\n- Remember that tuples are immutable, so you can't modify their elements.\n- Use a `try-catch` block to catch errors if an operation fails.\n:::\n\n::: {.callout-caution collapse=\"true\" icon=false}\n## Correction of Exercise 3:\n\n::: {#6e2f4fc2 .cell execution_count=33}\n``` {.julia .cell-code}\n# Create an array of integers from 1 to 10\narr = collect(1:10)  # Convert UnitRange to an array\n\n# Use broadcasting to multiply all elements of the array by 2\narr .= arr .* 2  # Broadcasting .*= operator\nprintln(\"Modified array: \", arr)\n\n# Create a tuple with three elements: a string, an integer, and a float\nt = (\"John\", 25, 5.9)\n\n# Attempt to mutate the first element of the tuple with error handling\ntry\n    t[1] = \"Alice\"  # This will raise an error because tuples are immutable\ncatch e\n    println(\"Error: \", e)\nend\n\n# Create a NamedTuple with fields: name, age, and height\nnt = (name = \"John\", age = 25, height = 5.9)\n\nprintln(\"NamedTuple: \", nt)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nModified array: [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\nError: MethodError(setindex!, ((\"John\", 25, 5.9), \"Alice\", 1), 0x00000000000068fc)\nNamedTuple: (name = \"John\", age = 25, height = 5.9)\n```\n:::\n:::\n\n\n:::\n\n",
    "supporting": [
      "fundamentals-basic-types_files"
    ],
    "filters": [],
    "includes": {}
  }
}