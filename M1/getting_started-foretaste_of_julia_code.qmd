---
title: "Foretaste of Julia code"
page-layout: article
jupyter: julia-1.11
---

```{julia}
#| echo: false
using Pkg
using Suppressor
@suppress begin
  Pkg.activate(".")
end
```

## Variables

```{julia}
x = 1
2x
```

```{julia}
x = sqrt(2)
```

```{julia}
# unicode is great
x = âˆš(2)
```

```{julia}
ðŸ˜„ = sqrt(2)
2ðŸ˜„
```


::: {.callout-note}
Visit the list of [Unicode characters](https://docs.julialang.org/en/v1/manual/unicode-input/).
:::

## Functions

```{julia}
# this is a function
function f(x)
  return 2x+1
end
```

To evaluate a function, simply write:

```{julia}
f(2)
```

```{julia}
# this is also a function
g(x) = 2x+1
```

```{julia}
# this is also a function
h = x -> 2x^2
```

```{julia}
# be careful of the priorities
h(1)
```

Another function manipulating strings.

```{julia}
Hello(name) = "Hello " * name * "!"
Hello("Alban")
```

## Side effects

Let consider the following vector.

```{julia}
x = [1, 3, 12]
```

You can access the second component like this:

```{julia}
x[2]
```

To update the second component, simply replace the value.

```{julia}
x[2] = 5
```

Be cautious when a function mutates a vector. The following function has side effects that can be dangerous.

```{julia}
function f(x, y)
    x[1] = 42      # mutates x
    y = 7 + sum(x) # new binding for y, no mutation
    return y
end

a = [4, 5, 6]
b = 3

println("f($a, $b) = ", f(a, b))
println("a = ", a, " # a[1] is changed to 42 by f")
println("b = ", b, " # the scalar b is not changed")
```

When a function has [side effects](https://en.wikipedia.org/wiki/Side_effect_(computer_science)), please use the bang convention, that is add a `!` at the 
end of the function's name.
See [Argument Passing Behavior](https://docs.julialang.org/en/v1/manual/functions/#man-argument-passing).

```{julia}
function put_at_second_place!(x, value)
  x[2] = value
  return nothing
end

x = [1 3 12]
println("x[2] = ", x[2])

put_at_second_place!(x, 5)
println("x[2] = ", x[2])

put_at_second_place!(x[1:3], 15) # be careful if you give a slice
println("x[2] = ", x[2])
```

## Methods

A function may have several methods.

```{julia}
Î£(x::Float64, y::Float64) = 2x + y
```

```{julia}
Î£(2.0, 3.0)
```

```{julia}
#| error: true
Î£(2, 3.0)
```


```{julia}
f(x::Number,  y::Number ) = 2x - y
f(x::Int,     y::Int    ) = 2x * y
f(x::Float64, y::Float64) = 2x + y
```

```{julia}
println("h(2,   3.0) = ", f(2, 3.0))
println("h(2,   3  ) = ", f(2, 3))
println("h(2.0, 3.0) = ", f(2.0, 3.0))
```
